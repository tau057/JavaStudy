# ⑤まとめ

## 課題９ ドローメソッドの改修 解答

```
    public Card draw() {

        // 残り枚数
        int remainingNumber = cards.size();

        // 残り枚数が0枚の時はその旨を表示して処理終了
        if (remainingNumber <= 0) {
            System.out.println("山札にカードがありません");
            return null;
        }

        // リストサイズを使用して乱数を発生させる
        // リストサイズ（カードの枚数）が10なら、0~9の範囲で
        Random rand = new Random();
        int cardIndex = rand.nextInt(remainingNumber);

        // リストからカードを取得
        Card drawCard = cardList.get(cardIndex);

        // ドローしたカードを削除
        cardList.remove(cardIndex);

        // ドローしたカードを返す
        return drawCard;

    }
```

### (閑話) プログラミングの３大要素

実はここまでで、以下のプログラミングの３大要素を全て扱いました  
（順次処理は特に意識することはなかったかもしれませんが...）  
  
* 順次処理
* 分岐処理
* 反復処理

この３つの処理さえあれば、どのようなアルゴリズムであっても実現可能です  
もうすでに、どんな処理でも実現可能な能力が身についたということですね  
(効率や記述のきれいさなどを度外視すればの話だけど)


## まとめ

### この章でやったこと

* 山札クラスを作成した
  * if文を使った
    * 演算子の復習
  * 乱数を使った
    * 疑似乱数の説明

ここまでで山札とカードを実装することができました  
山札のインスタンスを作成した瞬間に全てのカードが生成され、  
ランダムに一枚カードを引く操作も実装しましたね  
簡単な占い程度であればすでに実装できるかもしれません  
  
とはいえ我々の目標はブラックジャック  
次の章でも新たにクラスを追加して、実装を進めていきましょう!  
  
と、言いたいところなのですが...  
もしかしたらそろそろこんなことを思い始めてきたのではないでしょうか

* あといくつクラス作ったら終わるの？
* クラス追加すると、既存クラスの修正必要なことあって面倒だったな

というわけで、ここまではjavaの仕様やアルゴリズムになれるために  
先に考えやすいクラスを作成してきましたが、  
本来のシステム開発の流れに戻って、一旦設計をしてみましょうか  
  
設計を適切に行うことで、作業ボリュームを把握しやすくなるほか  
クラス追加時の修正などの手戻りを減らすことができますよ  